{smcl}
{cmd:help gendummies}
{hline}

{title:Title}

{p2colset 5 20 22 2}{...}
{p2col :gendummies {hline 2}}Generates batterie(s) of dummy variables with suffixes taken from category codes{p_end}
{p2colreset}{...}


{title:Syntax}

{p 8 16 2}
{opt gendummies} {varlist} [{cmd:,} {it:options} ]

{p 8}or

{p 8 16 2}
{opt gendummies} [stubprefix:]{varlist} [{cmd:,} {it:options}] [ {bf:||} [stubprefix:]{varlist} [ {bf:||} ... ]


{p 8}The second syntax permits the same options to be applied to multiple varlists.



{synoptset 18 tabbed}{...}
{synopthdr}
{synoptline}
{synopt :{opth stu:bprefix(name)}}Prefix for the stubname of generated dummy variable (default is to use 
the name of the variable from which the dummies are generated unadorned by any prefix){p_end}
{synopt :{opth nostu:bprefix(varname)}}empty the stubprefix option (useful if wanting to 
define the stubprefix at the start of the varlist to which it applies.{p_end}
{synopt :{opt inc:ludemissing}}Include missing values as zeros{p_end}

{p 4}None of these options are required.{p_end}


{title:Description}

{pstd}
{cmd:gendummies} generates batterie(s) of (optionally {bf:stub}-prefixed) dummy variables from categorical variable(s), 
using as suffixes the codes actually found in the data, with the option to code missing categories as zeros; 
especially useful when a battery question asks about only one pole of a bipolar topic. Such batteries provide 
a convenient mechanism for including categorical information in stacked data.{break}
{space 3}Any variable for which a {bf:stubprefox} is not provided 
will be named by using as stub the name of the variable whose categories are being expanded into separate dummies. 
Resulting variables are labled with the original varliable's corresponding value labels, if any.{break}
{space 3}{cmd:gendummies} uses the codes found in the data as suffixes for the generated 
variables, thus permitting users to ensure consistent codes across disparate batteries of responses (e.g. behaviours, 
attitudes, etc.) relating to the same items (e.g. political parties). This is in contrast to Stata's {cmd:tab1}, 
which uses sequential suffixes starting at the number 1 for the generated variables, no matter how those variables 
were coded. 

{pstd}
SPECIAL NOTE ON MULTIPLE BATTERIES. In datasets derived from election studies (and perhaps more generally) 
it is quite common for some questions to be repeated in regard to different objects (eg. politial parties), producing 
what {cmd:stackMe} refers to as a battery of questions, one for each battery object. It is not uncommon in with such 
batteries for them to cover only a subset of the 
objects being investigated (eg. parties). Moreover, questions relating to those 
objects may not always list them in the same order. Thus not only may the number of items in the resulting battery 
be different from those in another battery but also the numeric suffixes generated by 
{cmd:gendummies} may refer to different objects for different batteries.{break}
{space 3}Yet stacked datasets (the type of datasets for which batteries of dummy variables are normally wanted) 
absolutely require all batteries pertaining to the objects that were stacked to have the same ID numbers for the 
same items, which only the user can check.


{title:Options}

{phang}
{opt stu:bprefix(name)} Optional prefix for the stub used to name the generated dummy variable. Default is to use 
as stubname the name of each variable from which dummies are being generated (recommended); but the ability 
to differentiate between different versions of the same battery can be helpful.{p_end}

{phang}
{opt nostu:bprefix(name)} Delete a previously defined prefix so that the stubname reverts to the unadorned name 
of the variable whose categories define the dummy variables.

{phang}
{opt inc:ludemissing} if specified, missing values for {it:varname} will be coded as all zeros.

{p 4}All options have default settings.

{pstd} {bf:Note that} The most effective procedure is generally 
to use Stata's {help rename group} command (see especially Rule 17) to rename variables appropriately before invoking 
{cmd:gendummies} with the first (standard STATA) syntax. The second syntax is included for conformity with 
{help stackme} syntax used elsewhere.

{pstd} SPECIAL NOTE ON STACKING CATEGORICAL VARIABLES. Using {cmd:gendummies} as a preliminary to stacking 
a normal survey item with less than 10 categories is an easy way to produce a corresponding stacked variable. But 
if the cetegorical variable has significantly more categories than that, this uses up a lot of space in the 
unstacked data and is not very useful when stacked. A more economical procedure is to let the many-categoried 
item be duplicated onto the separate stacks (the natural fate for variables that are not reshaped during stacking) 
and use logical expressions to derive one or more corresponding stacked variables (eg. 'generate vote = ptyvot==ptyid', 
which produces a dummy variable equal to 1 where the expression is true (in this example, where the party voted for 
is the party of that stack) and 0 otherwise.



{title:Examples:}

{phang2}{cmd:. gendummies relig:denom churchat || educ || dummy:gender }{p_end}

{pstd}Generate dummies named "relig_denomX" "relig_churchatX" "educX" and "dummy_genderX" for different values (X) found 
in the data for the variables {it:denom churchat} {it:educ} and {it:gender}; missing values on the original variable(s) 
will produce missing values on all of the corresponding dummy variables.{p_end}

{phang2}{cmd:. gendummies rdenom educ gender, includemissing}{p_end}

{pstd}Generate dummies for different values of the same variables as in the first example, but naming all of these 
by appending, to the original variable names (used as stubnames), suffixes identifying the values found; use of the 
option {it:includemissing} ensures that missing values on any of these variables will coded zero on all the resulting 
dummy variables.{p_end}

