
capture program drop genyhatsP					// Originally `genyhats', in Version 2 is called by `stackmeWrapper'

program define genyhatsP				
												// In v2 stackmeWrapper extracts working data before calling `cmd'P, afterwards 
												// merging the results back into the origial dataset
*set trace off
  
*! gendyhatsP version 2 for Stata version 9.0 (2/23/23 by Mark) has options cumulating as extra varlists are processed 
*! Minor tweaks Nov'24 to handle revised weighting strategy.

	// This is a rewrite of the version 1.5 genyhats (the version that processed multiple varlists, using byable code), 
	// renamed genyhatsP to make it callable from the version 2.0 stackMe wrapper (itself called from genyhats.ado).
	//    The stackmeWrapper calls genyhatsP once for each data context. It has added sevaral options tp the original
	// call that transmit information acquired by the wrapper that was previously supplied within this program. Option 
	// `extradiag' is now a standard stackMe option determining the verbosity of the output. Option `quietly' replaces 
	// the previous `outmode' local governing this verbosityt. Option `prefix' tells genyhatsP whether the `opt1' 
	// processed by the wrapper was supplied as a prefix to the depvarlist rather than as an option.
	//    CRITICALLY, the presence or absence of a prefix to the depvarlist determines whether yhats are produced
	// by bivariate or multivariate analyses (multivariate if the depvar is supplemented by the prefix or if optioned).
	

																// genyhats-specific lines of code are suffixed with "**"
																
																
	
	version 16.1							// (0) genyhatsP version 2 preliminaries

	
	
*****************
capture noisily {												// introduces codeblocks within which any error will be captured 
*****************



																//(will be handled after the close capture brace
	syntax anything(id="varlist") [if][in][aw fw iw pw],[DEPvarname(varname) CONtextvars(varlist) ITEmname(varname) LOGit]  ///
	[ DPRefix(string) IPRefix(string) APRefix(string) MULtivariate ] ///
	[ REPlace prfx(string) ADJust(string) EFFects(string) EFOrmat(string) limitdiag(integer -1) EXTradiag NODIAg ]			///
	[ NOCONtexts NOSTAcks nvarlst(integer 1) ctxvar(string) nc(integer 0) c(integer 0) wtexplst(string) * ] 
	
//  USING STRING PREFIX TO INPUT VAR:
*	AN OUTCOME NAME GENERATED BY A `cmd'P SUBPROGRAM WILL HAVE AS INTERIM PREFIX THE INITIAL DIFFERENTIATING THE VAR FROM OTHER VARS	***
*	GENERATED BY THAT SUBPROGRAM. IN 'cleanup' THAT PREFIX WILL BE REPLACED ACCORDING TO USER OPTION AND EXTENDED BY PREPENDING THE
*	COMMAND-SPECIFIC PREFIX FOR THIS COMMAND ('y' FOR 'genyhats'). THE `cmd'P SUBPROGRAM MAY WANT TO EMULATE THAT PREFIX FOR DIATNOSTIC
*	DISPLAY PURPOSES.
	
																// NOTE THAT FINAL `wtexplst' WILL REPLACE [aw...], if any, below
																// Additionally, global multivariate was initialized in wrapper
	
																// Wrapper adds optns following limitdiag
																// NOTE THAT prfx and `isprfx' are absent 'cos redundant				**
global errloc "genyh(1)"
	
	
											// (1) deal with options (these are the same for all varlists in set)
											
	if MULTIVARIATE !=""  local multivariate = "yes"
	
	local isprfx = ""											// By default there is no prefix, so not a multivariate analysis
																// (unless `multivariate' was optd (now in $multivariate))
	if (`limitdiag' == -1)  local limitdiag = .					// Make that a very large number
	if ("`extradiag'"!="")  local limitdiag = .					// Ditto
	if (`limitdiag' == 0)	local quietly = "quietly"
	else  {														// Else `extradiag' is empty
		if `limitdiag'<=`c'  local limitdiag = 0				// And `limitdiag' becomes =0 if  `c' is >=`limitdiag'
	}
	
	if `c'==1  {												// MOVE THIS CODEBLOCK TO genyhatsO WHEN IMPLEMENTED				***
		local apr = "_"											// By default `apr' contains just the final "_" of var prefix
		if "`aprefix'"!=""  local apr = "`aprefix'"				// If `aprefix' was optioned it replaces that "_"
	
		local dpr = "d`apr'"									// By default `dpr' is "d" followed by `apr' (usually just "_")
		if "`dprefix'"!="" local dpr = "`dprefix``apr'"			// If a different `dprefix' was optioned, it replaces the "d"
	
		local ipr = "i`apr'"									// Ditto for `ipr'
		if "`iprefix'"!=""  local ipr = "`iprefix'`apr'"
	}	
																// WEIGHT IS APPLIED SEPARATELY FOR EACH nvarlst, below
	if "`adjust'"!=""  {
	   local cen = substr("`adjust'",1,3)						// Require only 1st 3 chars of keyword								***
	   foreach str in "mea con no"  {
		  if "`cen'"!="`str'"  continue							// If not matched continue with next str
		  local `cen' = "`str'"				
		  continue, break										// Break out of loop if found a match
	   }	
	} //endif
	
	else  local cen = "null"									// Seemingly need to initialize this local even if empty
			
	if `c'==1  {
			
	  if (`limitdiag'!=0 & `c'==1) { 							// display for first context if optioned
		local contextlabel : label lname `c'					// Retrieve the label for this context built by _mkcross			**
		noisily display "Y-hats will be separately generated by context (and stack)" _continue
		if "`extradiag'"!="" noisily display "(starting with {result:`contextlabel'})" _newline
	  }
	  else display " " _newline
	  
	} //endif `c'==1
																// All of the above is overhead repeatd for each `cmd'P 

				
				
				
				
global errloc "genyh(2)"

				
				
				
											// (2) HERE STARTS PROCESSING OF CURRENT CONTEXT . . .
											
			
	quietly count 	
	local numobs = r(N)											// N of observations in this context
			
																// Whether or not `multivariate' was optiond, that opt can be overriddn
	forvalues nvl = 1/`nvarlst'  {						 		// Cycle thru varlists included in possible multivarlist
																// (default prefix is in option `depvarname')
		 local isprfx = ""										// Flag tells 'predcent' if this is a multivariate analysis
		 local dvar = GOTAT`nvl'								// If there was a yh@ prefix, depvar is in scalar (else use optd versn)
		 if "`dvar'"==""  local dvar = "`depvarname'"			// `dvar' is local version of (prhps optd) `depvarname', which is default
		 local prfxvars = PRFXVARS`nvl'							// Retrieve any prefixvar from relevant scalar primed before wrapper(3)
		 if "`prfxvars'"!="" & "`prfxvars'"!="."  {				// If prefixvar is non-empty/non-missing this is a multivariate analysis
		   local isprfx = "yes"									// If there is a prefixvar then this is a multivariate genyhats
		   local prfxstr = PRFXSTRS`nvl'						// Retrieve string prefix to that var, if any
		   if "`prfxstr'"!=""  {
		   	  if "`prfxstr'"=="yh"  local prfxstr = "yd"
		   	  local dpr = "`prfxstr'`apr'"						// If `prfxstr' is not empty, override any existing `dpr' (set above)
		   } //endif `prfxstr'
		 } //endif `prfxvars'									// Else will generate bivariate yhats (unless user optn overode default)
																// SEEMINGLY A LOT OF REDUNDANCY ABOVE									***
																
		 local indepvars = VARLISTS`nvl'

		 if `c'==1  {				 							// Display these diagnostcs while processng 1st contxt					**
		   if `limitdiag' !=0 & `c'<=`limitdiag'   {			// (or for all contexts if extradiag was optioned)														
			 if "`multivariate'"==""  { 	   					// If analysis will produce multiple bivariate yhats
			   noisily display "Regressing {bf:`dvar'} separately on (each) y`ipr'-prefixed {bf:`indepvars'}; `nostacks' `nocontexts'"
			 }
			 else  {											// Else analysis will produce one multivariate yhat
			   noisily display _newline ///
				 "Regressing `dvar' on `indepvars', saving Y-hat in {result:y`dpr'dvar}; `nostacks' `nocontexts'"
			 } //endelse
		   } //endif `limitdiag'
		 } // endif `c'==1																												**
				
				
		 if "`wtexplst"!=""  {									// Now see if weight expression is not empty in this context
																// (`wtexp' is not taken from [aw...] expression but from final option)
			local wtexp = word("`wtexplst'",`nvl')				// Obtain local name from list to address Stata naming problem
			if "`wtexp'"=="null"  local wtexp = ""
				 
			if "`wtexp'"!=""  {									// If 'wtexp' is not empty (don't non-existant weight)
				local wtexp = subinstr("`wtexp'","$"," ",.)		// Replace all "$" with " "
			}
			
		 } //endif 'wtexplst'
		
		
	
	
	
		
		
global errloc "genyh(3)"
	
	
	
	

											// (3) Heavy lifting is done in program predcent (below)
											
set tracedepth 5
*		 ********
		 predcent `indepvars' `wtexp', depvarname(`dvar') cen(`cen') isprfx(`isprfx') logit(`logit') limitdiag(`limitdiag')
*		 ********												// Code for called program follows code for this one
set tracedepth 4
				


				
				
				
				
global errloc "genyh(4)"




											// (4) Post-process the results, if optioned
											
					
		 if ("`effects'"!="" & "`effects'"!="no") {				// I DON'T KNOW HOW TO TIDY THE OUTPUT								***

			local usefile = ""
			if ("`effects'"!="window") {
				local usefile = "using `yhat'.`effects'"
			}

			else {
				quietly display "{p_end}" _continue
			}

			if ("`logit'"=="logit") {							// Logit analysis
				local cellfmt = "z(fmt(3) star)"
				if ("`efmt'"!="") {
					local cellfmt = "`efmt'"
				}
				esttab `usefile', cells("`cellfmt'") pr2(%8.3f) mtitles replace compress wide onecell plain label
			}

			else {												// Regression analysis
			
				local cellfmt = "z(fmt(3) star)"
				if ("`efmt'"!="") {
					local cellfmt = "`efmt'"
				}

				if ("`efmt'"=="beta") {
					esttab `usefile', beta(%8.3f) not constant star ar2(%8.3f) mtitles replace compress wide onecell plain label
				}

				else {
					esttab `usefile', cells("`cellfmt'") ar2(%8.3f) constant mtitles replace compress wide onecell plain label
				}

			} //end else

		 } //endif `effects'
	
	


global errloc "genyh(5)"
	
											// (5) Break out of `nvl' loop if `postpipes' is empty
											// 	   (or pre-process syntax for next varlist)

		 if "`postpipes'"==""  continue, break					// Break out of `nvl' loop if `postpipes' is empty 
																// Else ...
		 local anything = strltrim(substr("`postpipes'",3,.))	// Strip leading "||" and any blanks from head of `postpipes'
																// (`anything' now contains next varlist and any later ones)
		 local isprfx = ""										// Switch off the prefix flag if it was on

				   
				   
	   } //next `nvl' 											// (next list of vars having same options)
				
/*	   if $exit==0 {											// COMMENTED OUT COS NOW DONE IN WRAPPER
		  if (`nc' > 1 &`limitdiag'!=0  &`c'<`limitdiag') { 	// Display diagnostics, if optioned
			 noisily display _newline "Context {result:`c'} ({result:`contextlabel'}) has `numobs' cases"
		  }
	   }
*/			


	local skipcapture = "skip"									// If this command is executed then there were no errors above


	
* *************
} //end capture
* *************



if _rc & "`skipcapture'"==""  {

	errexit "Stata has diagnosed a program error"
	exit _rc

} //endif _rc
			
	

end genyhatsP



******************************************************** END genyhatsP ********************************************************





***************************************************** SUBROUTINE predcent *****************************************************



capture program drop predcent  				
											

program define predcent   					// Program to predict and center variable(s) on their means/constants

	version 9.0

	syntax varlist [aw fw iw pw] , depvarname(varname) cen(string) [ logit(str) isprfx(str) extradiag(str) * ]
								   
								 
								 
		
global errloc "predcent"
	
	
	
*****************
capture noisily {											// introduces codeblocks within which any error will be captured 
*****************



								 
								 
	if "`cen'"=="null"  local cen = ""						// Argument cannot travel as an empty string; should be absent
	
	if "`weight'"!="" local wt = "[`weight'`exp']"
	if "`extradiag'"==""  local quietly = "quietly"			// By default `quietly' is empty

	local dvar = "`depvarname'"
*	local cen = "`center'"
	local nvars = wordcount("`varlist'")
	
	
	if "`isprfx'"!="" | "$multivariate"!=""  {				// Multivariate analysis for which `varlist' provides indeps
*		global multivariate = "multivariate"				// (SHOULD HAVE BEEN DONE IN wrapper)
															// (global established in wrapper according to user option)
		local yhat = /*"`ydprefix'"*/"d_`depvarname'"		// (yhats have additional "y" prefix but NOW DONE IN 'cleanup')
 
		capture quietly generate `yhat' = .					// By default make the yhat missing

		if "`logit'"==""  {									// If `logit' was NOT optioned ...
			`quietly' capture reg `dvar' `varlist' `wt'		// `quietly' is effected unless `extradiag' was optioned above
			local rc = _rc									// Save RC for use below
/*															// NEXT LINES COMMENTED OUT 'COS DONT WANT 'reg' CMD TWICE		***
			if "`extradiag'"!="" reg `dvar' `varlist' `wt'  // If insufficient obs or other error, leave result missing
			else  qui capture reg `dvar' `varlist' `wt'		// Quietly unless extradiag was optioned
*/		}
		
		else  {												// Else `logit' WAS optioned
*			qui capture logit `dvar' `varlist' `wt' 		// COMMENTED OUT 'COS DONT WANT 'logid' CMD TWICE
			`quietly' logit `dvar' `varlist' `wt' 			// `quietly' is effected unless `extradiag' was optioned above
*			else qui logit `dvar' `varlist' `wt'			// COMMENTED OUT 'COS DONT WANT 'logit' CMD TWICE
			local rc = _rc									// If insufficient obs or other error, leave result missing
		}

		if `rc'==0  {										// If there are sufficient cases for this analysis
			tempvar NN			
			quietly predict `NN'							// Tempvar holds prediction that will replace `yhat'
			quietly replace `yhat' = `NN'

			if "`cen'"!=""  {								// If centering was optioned ...
				if "`cen'"=="con" {
					local adj =_b[_cons]					// Adjust by subtracting constant if optioned
				}											// (both _b and _cons are system _variables (see 'help _variables'))

				else  {										// Else subtract mean ...
					quietly sum `yhat' `wt', meanonly		// Need weighted mean of the `yhat'
					local adj = r(mean)
				}

				if "`logit'"==""  {
					quietly replace `yhat' = `yhat' - `adj' // This is a regression adjustment (straightforward)
				}											

				else  {					
					tempvar exponNN							// Else this is a logit adjustment ...
					qui gen `exponNN' = logit(`yhat')
					if "`cen'"=="con"  {
						replace `yhat' = invlogit(expon`NN'-_b[_cons])
					}										// (both _b and _cons are system _variables (see 'help _variables'))

					else  {									// Need weighted mean of the logit(`yhat')
						quietly sum `exponNN' `wt', meanonly 
						quietly replace `yhat' = invlogit(`exponNN'-r(mean))
						capture drop `exponNN'
					}

				} //end else logit adjustment

			} //endif centering

			drop `NN'
				
		} //endif _rc

	} //endif $multivariate


		
	else  {											 		// Multiple bivariate analyses: one analysis for each indep

		foreach indep of local varlist  {					// (yhats have `iprefix') 

			local yhat = "i_`indep'"
			capture quietly generate `yhat' = .				// By default make the yhat missing

			if "`logit'"==""  {								// If `logit' was NOT optioned ...
				capture `quietly' reg `dvar' `indep' `wt'
				local rc = _rc								// If insufficient obs or other error, leave result missing
*				if (`rc' == 0 & "`extradiag'"!="") reg `dvar' `indep' `wt'
			}												// ABOVE LINE COMMENTED OUT 'COS DONT WANT `reg' CMD TWICE

			else {											// Else `logit' was optioned
				capture logit `dvar' `indep' `wt'
				if (_rc == 0 & "`extradiag'"!="") logit `dvar' `indep' `wt'
				local rc = _rc								// If insufficient obs or other error, leave result missing
			}
				
			if `rc'==0  {									// If sufficient cases for this analysis

				tempvar NN									// Tempvar holds predictions that will replace `yhat's
				quietly predict `NN'
				quietly replace `yhat' = `NN'

				if "`cen'"!=""  {							// If centering was optioned ...
					if "`cen'"=="con"  {
						local adj = _b[_cons]				// Adjust by subtracting constant if optioned
					}

					else  {									// Else subtract mean ...
						qui sum `yhat' `wt'	, meanonly		// Need weighted mean of the yhaat
						local adj = r(mean)
					}

					if "`logit'"==""  {
						quietly replace `yhat'=`yhat'-`adj' // This is a regression adjustment (straightforward)
					}											

					else  {					
						tempvar exponNN						// Else this is a logit adjustment ...
						qui gen `exponNN' = logit(`yhat')
						if "`cen'"=="con"  {
							replace `yhat' = invlogit(expon`NN'-_b[_cons])
						}									// (both _b and _cons are system _variables (see 'help _variables'))

						else  {								// Need weighted mean of the logit(`yhat')					***
							quietly sum `exponNN' `wt', meanonly 
							quietly replace `yhat' = invlogit(`exponNN'-r(mean))
							capture drop `exponNN'
						}

					} //end else logit adjustment

				} //endif centering

				drop `NN'

			} //endif _rc

		} //next `indep'

	} //end else bivariate
	
	
	local skipcapture = "skip"
	
	
	
* *************
} //end capture
* *************



if _rc & "`skipcapture'"!=""  {
	
	errexit "program error"
	
}

	
	
	
end predcent



***************************************************** END SUBROUTING predcent **************************************************


